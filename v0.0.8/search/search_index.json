{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Aqueduct","text":"<p>Aqueduct, an experiment control software (ECS) is what we call the collection of software that labs use to run experiments. Every lab, whether commercial or academic, has an ECS (albeit with varying capabilities). The opportunity in this space we see is that existing ECS solutions are mediocre and emerging use-cases for quantum computing (QC) systems are introducing new software infrastructure requirements that labs do not want to develop on their own. Key examples of these new needs can be observed in the software needed in testbed systems: support for multiple users, better data management systems, and automation.</p> <p>The minimum viable product (MVP) we are launching is a system for storing, browsing and searching experiment results. A data management system is a key requirement for larger systems that will be shared (e.g., testbeds) as users will not want their data intermingled with that of others. Our overwhelming observation is that the quantum ecosystem lacks good data management solutions. Furthermore, data management is a minimally disruptive to the work the lab does and can adapt to many lab setups; as such it is low risk for many labs to test the product.</p> <p>Our goal is to develop a set of usable, reliable, and well-supported software tools that will displace the hand-rolled and brittle software that currently runs most labs. Our business strategy segments our users based on whether they are running experiments (e.g., academic labs, startup commercial labs) of if they are building larger systems or testbeds (e.g., scale ups). This segmentation is conducive to a freemium model: we will give away software to users, who will self-serve, in the former category to increase credibility, build goodwill and drive adoption. We will monetise the latter category by selling premium versions of the software with features relevant to that segment, along with charging for the work needed to integrate our software with the rest of their system.</p>"},{"location":"getting-started/","title":"PyAqueduct Application Programming Interface (API) Tutorial","text":"<p>In this tutorial, the API of PyAqueduct is introduced by working on a sample experiment. The sample experiment generates some results in the form of different files such as CSV, JSON, HDF5, and image files. Each execution of the experiment generates new set of files and therefore, is treated as a new experiment run.</p>"},{"location":"getting-started/#experiment-analysis-of-projectile-motion","title":"Experiment: analysis of projectile motion","text":"<pre><code># Install experiment dependecies.\nimport sys\n!{sys.executable} -m pip install numpy pandas matplotlib h5py\n</code></pre> <pre><code>import os\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport json\nimport h5py\n\n\ndef simulate_projectile_motion(v0: float, angle: float, g: float = 9.81) -&gt; pd.DataFrame:\n    \"\"\"\n    Simulates the projectile motion.\n\n    Args:\n        v0: Initial velocity in m/s.\n        angle: Launch angle in degrees.\n        g: Acceleration due to gravity in m/s^2 (default is 9.81).\n\n    Returns:\n        DataFrame containing time, x and y positions.\n    \"\"\"\n    # Time of flight calculation\n    t_max = 2 * v0 * np.sin(np.radians(angle)) / g\n    time_steps = np.linspace(0, t_max, num=50)\n\n    # Position calculations\n    x = v0 * np.cos(np.radians(angle)) * time_steps\n    y = v0 * np.sin(np.radians(angle)) * time_steps - 0.5 * g * time_steps**2\n\n    return pd.DataFrame({\"Time (s)\": time_steps, \"X Position (m)\": x, \"Y Position (m)\": y})\n\n\ndef save_data_formats(data: pd.DataFrame, base_path: str) -&gt; None:\n    \"\"\"\n    Saves data in different formats: CSV, JSON, and HDF5.\n\n    Args:\n        data: Data to save.\n        base_path: Base file path without extension.\n    \"\"\"\n    # CSV\n    csv_path = f\"{base_path}.csv\"\n    data.to_csv(csv_path, index=False)\n\n    # JSON\n    json_path = f\"{base_path}.json\"\n    with open(json_path, \"w\") as json_file:\n        json.dump(data.to_dict(orient=\"records\"), json_file)\n\n    # HDF5\n    hdf5_path = f\"{base_path}.hdf5\"\n    with h5py.File(hdf5_path, \"w\") as hdf_file:\n        for column in data.columns:\n            hdf_file.create_dataset(column, data=data[column].values)\n\n\ndef plot_trajectory(data: pd.DataFrame, image_path: str) -&gt; None:\n    \"\"\"\n    Plots the trajectory of the projectile motion.\n\n    Args:\n        data: Data containing the trajectory.\n        image_path: Path to save the plot image.\n    \"\"\"\n    plt.figure(figsize=(8, 6))\n    plt.plot(data[\"X Position (m)\"], data[\"Y Position (m)\"])\n    plt.title(\"Projectile Motion Trajectory\")\n    plt.xlabel(\"X Position (m)\")\n    plt.ylabel(\"Y Position (m)\")\n    plt.grid(True)\n    plt.savefig(image_path)\n\n\n# Parameters for the simulation\ninitial_velocity = 20  # m/s\nlaunch_angle = 45  # degrees\n\n# Simulate the projectile motion\nprojectile_data = simulate_projectile_motion(initial_velocity, launch_angle)\n\n# Save the data in different formats\nbase_file_path = os.path.join(os.getcwd(), \"projectile_motion\")\nsave_data_formats(projectile_data, base_file_path)\n\n# Plot and save the trajectory\nplot_image_path = os.path.join(os.getcwd(), \"projectile_motion_plot.png\")\n\nplot_trajectory(projectile_data, plot_image_path)\n\nprint(\"Simulation and data processing completed.\")\n</code></pre>"},{"location":"getting-started/#create-experiment-on-aqueudct","title":"Create experiment on Aqueudct","text":"<pre><code>from pyaqueduct import API\n\napi = API(\"[AQUEDUCT_SERVER_URL_PLACE_HOLDER]\", timeout=1)\n\nexperiment = api.create_experiment(\n    title=\"Motion Simulation Experiment\", description=\"Tutorial experiment: motion simulation.\"\n)\n\nprint(f\"Experiment created with unique id: {experiment.alias}\")\n</code></pre>"},{"location":"getting-started/#add-tags-to-experiment","title":"Add tags to experiment","text":"<pre><code>experiment.add_tag(\"motion\")\nexperiment.add_tag(\"simulation\")\nexperiment.add_tag(\"notebook\")\n\nexperiment.tags\n</code></pre>"},{"location":"getting-started/#remove-tags-from-experiment","title":"Remove tags from experiment","text":"<pre><code>experiment.remove_tag(\"simulation\")\nexperiment.remove_tag(\"notebook\")\n\nexperiment.tags\n</code></pre>"},{"location":"getting-started/#update-experiment-and-file-downloadupload","title":"Update experiment and file download/upload","text":"<pre><code>experiment.title = \"Motion Simulation\"\nexperiment.description = \"Motion Simulation\"\n\nprint(f\"Experiment title: {experiment.title}\")\nprint(f\"Experiment title: {experiment.description}\")\nprint(f\"Experiment creation date: {experiment.created_at}\")\nprint(f\"Experiment last update date: {experiment.updated_at}\")\nprint(f\"Experiment tags: {experiment.tags}\")\n</code></pre>"},{"location":"getting-started/#upload-files","title":"Upload files","text":"<pre><code>experiment.upload_file(file=\"projectile_motion.csv\")\nexperiment.upload_file(file=\"projectile_motion.json\")\nexperiment.upload_file(file=\"projectile_motion.hdf5\")\nexperiment.upload_file(file=\"projectile_motion_plot.png\")\n</code></pre>"},{"location":"getting-started/#download-files","title":"Download files","text":"<pre><code>download_dir = os.path.join(os.getcwd(), \"downloads\")\nif not os.path.exists(download_dir):\n    os.makedirs(download_dir)\n\nexperiment.download_file(file_name=\"projectile_motion.csv\", destination_dir=download_dir)\nexperiment.download_file(file_name=\"projectile_motion.json\", destination_dir=download_dir)\nexperiment.download_file(file_name=\"projectile_motion.hdf5\", destination_dir=download_dir)\nexperiment.download_file(file_name=\"projectile_motion_plot.png\", destination_dir=download_dir)\n</code></pre>"},{"location":"getting-started/#get-specific-experiment","title":"Get specific experiment","text":"<pre><code>experiment = api.get_experiment(\"[Experiment ID]\")\n\nprint(f\"Experiment title: {experiment.title}\")\nprint(f\"Experiment title: {experiment.description}\")\nprint(f\"Experiment creation date: {experiment.created_at}\")\nprint(f\"Experiment last update date: {experiment.updated_at}\")\nprint(f\"Experiment tags: {experiment.tags}\")\n</code></pre>"},{"location":"setup/","title":"Setup Guide","text":"<p>On this page we provide instructions for two ways to set up Aqueduct: - Using production docker images - Installing from source</p>"},{"location":"setup/#using-production-docker-images","title":"Using Production Docker Images","text":"<p>For the ease of deployment in production, Aqueduct is released as a production-ready container image. The docker image is available through Dockerhub, <code>aqueducthub/aqueductcore</code>.</p> <p>This example Docker compose file shows how you can use the Docker images:</p> <pre><code>version: '3'\nservices:\n  aqueduct:\n    image: aqueducthub/aqueductcore:latest\n    restart: always\n    depends_on:\n      - postgres\n    environment:\n      EXPERIMENTS_DIR_PATH: /tmp/aqueduct_experiments\n      POSTGRES_USERNAME: admin\n      POSTGRES_PASSWORD: admin\n      POSTGRES_HOST: postgres\n      POSTGRES_PORT: 5432\n      POSTGRES_DB: aqueduct\n    volumes:\n      - /tmp/aqueduct_experiments:/tmp/aqueduct_experiments\n    ports:\n      - 80:8000\n\n  postgres:\n    image: postgres:15-alpine\n    restart: unless-stopped\n    environment:\n      - POSTGRES_USER=admin\n      - POSTGRES_PASSWORD=admin\n      - POSTGRES_DB=aqueduct\n    expose:\n      - 5432\n</code></pre> <p>Note</p> <p>If you are provided with a tar file to install Aqueduct, it already includes the docker image and related configurations. Please refer to the README.md file for further information.</p>"},{"location":"setup/#when-this-option-works-best","title":"When this option works best","text":"<p>This installation method is useful if you are familiar with Docker containers and Docker compose. It allows you to run Aqueduct components in isolation from other software running on the same physical or virtual machine with easy maintenance of dependencies.</p>"},{"location":"setup/#intended-users","title":"Intended users","text":"<ul> <li>Users who are familiar with containers and Docker, and understand how to build their own container images.</li> <li>Users who know how to create deployments using Docker by linking together multiple Docker containers and maintaining such deployments.</li> <li>Users who understand how to install providers and dependencies from PyPI with constraints, if they want to extend or customise the image.</li> </ul>"},{"location":"setup/#what-are-you-expected-to-handle","title":"What are you expected to handle","text":"<ul> <li>You are responsible for setting up database, creating and managing database schema with Aqueduct database commands, automated startup and recovery, maintenance, cleanup and upgrades of Aqueduct.</li> <li>You should choose the right deployment mechanism. There a number of available options of deployments of containers. You can use your own custom mechanism, custom Kubernetes deployments, custom Docker Compose, custom Helm charts etc., and you should choose it based on your experience and expectations.</li> <li>You need to setup monitoring of your system allowing you to observe resources and react to problems.</li> <li>You are expected to configure and manage appropriate resources for the installation (memory, CPU, etc) based on the monitoring of your installation and feedback loop.</li> </ul>"},{"location":"setup/#installing-from-source","title":"Installing from Source","text":"<ol> <li>Pre-requisites<ul> <li>Python installed on your system (version 3.8 or higher)</li> <li>PostgreSQL installed and running</li> </ul> </li> <li> <p>Clone the Repository Clone the repository of your Python web application from the source repository using git or download the source code.</p> <pre><code>git clone &lt;repository_url&gt;\ncd &lt;project_directory&gt;\n</code></pre> </li> <li> <p>Set up Virtual Environment (Optional but recommended)</p> <pre><code># Install virtualenv if you haven't already\npip install virtualenv\n\n# Create a virtual environment (replace 'env_name' with your preferred name)\nvirtualenv env_name\n\nsource env_name/bin/activate\n</code></pre> </li> <li> <p>Install Aqueduct     <pre><code>pip install &lt;project_directory&gt;\n</code></pre></p> </li> <li> <p>Set Environment Variables Before running the application, you need to set the required environment variables. These variables are essential for connecting to the PostgreSQL database and other functionalities.</p> <pre><code># Set the required environment variables (replace with your actual values)\nexport EXPERIMENTS_DIR_PATH=&lt;your_experiment_directory_path&gt;\nexport POSTGRES_USERNAME=&lt;your_postgres_username&gt;\nexport POSTGRES_PASSWORD=&lt;your_postgres_password&gt;\nexport POSTGRES_HOST=&lt;your_postgres_host&gt;\nexport POSTGRES_PORT=&lt;your_postgres_port&gt;\nexport POSTGRES_DB=&lt;your_postgres_database_name&gt;\n</code></pre> </li> <li> <p>Configure PostgreSQL: Ensure that your PostgreSQL database is properly configured and accessible with the provided credentials.</p> </li> <li> <p>Run the Application: Run the Python web application using the following command:     <pre><code>python app.py\n</code></pre> This command might differ based on how your application is structured and what file initializes your web server.</p> </li> <li> <p>Access the Application: Once the application is running, open a web browser and navigate to http://localhost: to access the application. Replace  with the port specified in your application setup."},{"location":"setup/#additional-notes","title":"Additional Notes:","text":"<ul> <li>Ensure the PostgreSQL server is running before starting the application.</li> <li>Make sure to keep sensitive information like passwords and usernames secure. Avoid hardcoding them in your code.</li> <li>Double-check the correctness of the environment variable values to avoid connection issues with the PostgreSQL database.</li> </ul>"}]}