{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Aqueduct","text":"<p>Aqueduct is the open platform that simplifies quantum experiment management.</p> <p>We are building Aqueduct to be a user-friendly, reliable, and well-supported solution for the emerging use-cases of quantum computing.  While qubit labs and companies focus on building better qubits, Aqueduct is here to assist in the bring-up, calibration, maintenance, and operation of quantum computers.</p> <p>In this current version of Aqueduct, we provide a user-friendly GUI and backend for storing, browsing, and searching for experiment results.  Your experiment data can be saved into Aqueduct with simple Python APIs which do not disrupt existing workflows.  We provide easy sorting and filtering of experiments, and quick previews of text and plots so you can easily find the data that you need.  Aqueduct is easy to try and easy to adopt.</p> <p>Upcoming features including support for multiple users, automation, and plug-ins.</p> <p>Quantum computers may be shared between users.  Aqueduct will support authentication and authorisation, so users can be assigned permissions to read and write data, and to have access to system functions.</p> <p>Calibration routines are often rerun regularly.  We will provide an automation solution for the scheduling of these jobs, as well as user experiments.</p> <p>A powerful plug-in SDK will allow for easy extensibility, allowing users to easily build additional functionality and integrations which can be private for their specific systems or public to be shared with the greater community. </p> <p>We welcome engagement from the community.  We would love to hear your ideas and needs for Aqueduct and we look forward to building new features together.</p> <p>Aqueduct will be a freemium product.  The core product will always be open source and free-to-use.  We reserve the right to charge for features not included in the core product and for non-community support. </p>"},{"location":"cli/","title":"Command Line Interface (CLI)","text":"<p>Aqueduct provides its Command Line Interface (CLI), <code>aqueduct</code>, with two main commands: <code>export</code> and <code>import</code>. These commands are used to export experiments data and files from the current Aqueduct instance into a <code>.tar.gz</code> file. This file can be later imported. This document provides a brief overview of how to use the Aqueduct CLI. For each command, it lists the usage, arguments, and options.</p>"},{"location":"cli/#global-options","title":"Global Options","text":"<ul> <li><code>--help</code>: Show the help message and exit.</li> </ul>"},{"location":"cli/#commands","title":"Commands","text":""},{"location":"cli/#export","title":"Export","text":"<p>The <code>export</code> command is used to export Aqueduct experiments' data into a GZIP compressed tar archive.</p>"},{"location":"cli/#usage","title":"Usage","text":"<pre><code>aqueduct export [OPTIONS] [PATH]\n</code></pre>"},{"location":"cli/#arguments","title":"Arguments","text":"<ul> <li><code>PATH</code>: [Optional] File path for the exported archive. Default is <code>/workspace/aqueduct_data_[YYYY_MM_DD].tar.gz</code>.</li> </ul> <p>Note:</p> <ol> <li>If the provided file path doesn't have a <code>.tar.gz</code> suffix, a warning message will be printed, but the file will be created with gzipped compressed tarball content.</li> </ol>"},{"location":"cli/#options","title":"Options","text":"<ul> <li><code>--experiment-files</code> (<code>-e</code>): Include experiments' files in the archive.</li> <li><code>--help</code>: Show the help message and exit.</li> </ul>"},{"location":"cli/#import","title":"Import","text":"<p>The <code>import</code> command is used to import Aqueduct experiments' data from a GZIP compressed tar archive.</p>"},{"location":"cli/#usage_1","title":"Usage","text":"<pre><code>aqueduct import [OPTIONS] FILE\n</code></pre>"},{"location":"cli/#arguments_1","title":"Arguments","text":"<ul> <li><code>FILE</code>: [Required] Tar file path of the archive to import. This argument is required.</li> </ul>"},{"location":"cli/#options_1","title":"Options","text":"<ul> <li><code>--help</code>: Show the help message and exit.</li> </ul>"},{"location":"cli/#notes","title":"Notes","text":"<ol> <li>Aqueduct CLI is installed alongside the web application. When using the official docker image of Aqueduct, the CLI is available inside the container and can be executed via <code>docker exec</code> command. For example:</li> </ol> <pre><code>docker exec &lt;container_name&gt; aqueduct export [OPTIONS] [ARCHIVE_PATH]\n</code></pre> <p>To download the archive from the container, you can use <code>docker cp</code> command. For example:</p> <pre><code>docker cp &lt;container_name&gt;:[ARCHIVE_PATH] ./\n</code></pre> <p>downloads the file to the current working directory.</p>"},{"location":"extensions/","title":"Extensions Setup Guide","text":"<p>On this page we provide information related to extension development, deployment and setup:</p> <ul> <li>What is an Extension</li> <li>Writing an Extension</li> <li>Writing a Manifest File</li> <li>Deploying an Extension</li> <li>Extension Setup</li> </ul>"},{"location":"extensions/#what-is-an-extension","title":"What is an Extension","text":"<p>Extension is a piece of software, which adds custom functionality to the server instance  (<code>aqueductcore</code> or <code>aqueductpro</code>) without server update or restart. One extension may include multiple actions, connected by common settings or area of responsibility. For example, a set of graph plotting actions, integration with a 3rd-party service, or a collection of quantum circuit simulation methods.</p> <p>Extensions may be implemented in any programming language if this language interpreter  or binary architecture is supported by the executing (virtual) environment. In the current implementation of extensions, their code is run on the Aqueduct server machine  (within server container, if you use containerised version). By default, <code>python3.10</code> and <code>bash</code> scripting  are supported.</p> <p>Extension execution may be triggered in one of two ways:</p> <ol> <li>Dropdown for extension choice is present inside the Experiment interface of the web application.</li> <li>User may call an extension action from <code>pyaqueduct</code> client API.</li> </ol>"},{"location":"extensions/#what-is-an-extension-technically","title":"What is an Extension Technically","text":"<p>Technically, extensions are directories with files which follow an extension convention. This convention is described in the chapters below.</p> <p>When server executes an extension action, the following steps are followed:</p> <ol> <li>Server application (<code>aqueductcore</code> or <code>aqueductpro</code>) checks the correctness of the extension definition (see chapter on Writing a Manifest File).</li> <li>Then it checks the existence of the python virtual environment inside the extension's directory. If there is no virtual environment inside, it gets created and the extension's dependencies are installed. You may control which packages are installed by adding <code>requirements.txt</code> and/or <code>pyproject.toml</code> files to the extension's directory. These dependencies are shared by all actions of the extension and installed once.</li> <li>Based on the manifest file and user input, parameters and constants are initialised as environment variables.</li> <li><code>script</code> section of the action definition is executed. This may call arbitrary code: scripts or programs located in the directory. If <code>$python</code> variable is used inside this section, it is replaced with the python executable of the virtual environment. Read more about writing the code in Writing an Extension section. We expect that these programs read the data and persist the results inside the aqueduct experiment.</li> <li>Execution output (standard input stream, standard error stream, process result code) is recorded in a log file which gets saved alongside the experiment's files.</li> </ol>"},{"location":"extensions/#writing-an-extension","title":"Writing an Extension","text":"<p>Extension may be fully written inside the <code>script</code> section of the manifest. But it is convenient to  separate its code into a dedicated file. Input values and constants are passed to this script file using environment variables (strings). To access these strings in python this code snippet may be used:</p> <pre><code>import os\nfrom tempfile import TemporaryDirectory\nfrom pyaqueduct import API\n\naq_url = os.environ.get(\"aqueduct_url\", \"\")\nvalue = os.environ.get(\"input_value\", \"\")\ninput_file = os.environ.get(\"input_filename\", \"\")\noutput_file = os.environ.get(\"output_filename\", \"\")\nexperiment_id = os.environ.get(\"experiment\", \"\")\n\napi = API(aq_url)\napi.get_experiment(experiment_id)\nwith TemporaryDirectory() as directory:\n    experiment.download_file(\n      file_name=input_file, \n      destination_dir=directory\n    )\n    ...\n    filename = f\"{directory}/{output_file}\"\n    with open(filename, \"w\") as file:\n      file.write(value)\n    experiment.upload_file(filename)\n</code></pre> <p>In a shell script variables start with <code>$</code> sign: <pre><code># this will be printed to standard output \n# and saved in the log file of the experiment\ncat $input_filename | sort\n# printing a variable\necho $string_value\ncurl \"$aqueduct_url/aqd/experiments/$experiment\"\n...\n</code></pre></p>"},{"location":"extensions/#writing-and-debugging-a-new-python-extension","title":"Writing and Debugging a New Python Extension","text":"<p>Start it simple. First, create three files on your local files system where <code>python</code> is installed, not necessarily the same machine as Aqueduct server.</p> <ol> <li>An extension action script, e.g. <code>action.py</code> with the following content:     <pre><code>import os\nimport requests\n\n\nif __name__ == \"__main__\":\n    aqueduct_url = os.environ.get(\"aqueduct_url\", \"\")\n    aqueduct_key = os.environ.get(\"aqueduct_key\", \"\")\n    var = os.environ.get(\"varname\", \"\")\n    print(f\"varname = {var}\")\n    response = requests.get(aqueduct_url + \"api/graphql\", timeout=3)\n    print(f\"URL: {aqueduct_url}, ok: {response.ok}\")\n</code></pre></li> <li>A <code>requirements.txt</code> file, where you will collect your dependencies:     <pre><code>requests&gt;=2.0.0\n</code></pre></li> <li>A <code>test.sh</code> with the following content:     <pre><code>venv=.aqueduct-extension-dev\n# recreate and populate a clean virtual env\n# comment these 3 lines if requirements are stable\nrm -r $venv\npython -m venv $venv\n$venv/bin/pip install -r requirements.txt\n\nexport aqueduct_url=\"http://localhost:8000/\"\nexport aqueduct_key=\"\"\n# TODO: add your parameters and constants below\nexport varname=123\n\n# run\n$venv/bin/python action.py\necho \"Result code: $?\"\n</code></pre></li> </ol> <p>Now, you may run and test your extension action as <code>sh test.sh</code>. Do changes of variables and constants by adding them to the <code>test.sh</code> file, and reading them with <code>os.environ.get(\"name\", \"\")</code> in python.</p> <p>If you update code of extension actions, or its dependencies, deleting <code>.aqueduct-extension-dev/</code>  will force virtual environment re-creation. If your dependencies are already stable, you may keep virtual environment directory to accelerate test runs.</p> <p>After you have finished development of the extension action code, copy <code>action.py</code> and <code>requirements.txt</code> files to the extension directory, and add <code>$python action.py</code> line to the <code>script</code> section in you manifest file (see details in Writing a Manifest File section). Then transfer constants and variables from <code>test.sh</code> to corresponding sections of <code>manifest.yml</code>. Note, that <code>aqueduct_url</code> string is always defined in the header of the file and shared among the actions. <code>aqueduct_key</code> variables is set by the Aqueduct server, you don't have to specify it.</p>"},{"location":"extensions/#writing-a-manifest-file","title":"Writing a Manifest File","text":"<p>After development is finished, you may prepare your new extension for deployment. First, create a directory for it. Extension directory may have and arbitrary name. Each extension directory must contain a YAML file called <code>manifest.yml</code>. This file defines information about the extension and its actions.  The example of the extension with two actions is given below:</p> <pre><code>name: \"Extension name\"\ndescription: &gt;\n  This is an extension from documentation.\n  Its descriptions supports \n  hyperlinks, e.g. https://riverlane.com\nauthors: ada.lovelace@gmail.com\naqueduct_url: http://localhost:8000/\n\n# constants, common for all actions:\nconstants:\n  common_shared_key: \"common value\"\n  common_shared_key_2: some other common value\n\n# list of actions and their definitions\nactions:\n  - \n    name: example python action\n    description: runs a python script\n    # use \"$python\" here to enable  \n    # virtual environment. Writing \"python\"\n    # without \"$\" will use the global python \n    # interpreter.\n    script: &gt;\n      $python script.py\n\n    # arguments of the action\n    parameters:\n      - \n        name: string_value\n        description: some string value entered in a textbox\n        data_type: str\n        default_value: default string\n      -\n        name: experiment\n        description: extension works with the data from this experiment\n        data_type: experiment\n      - \n        name: input_filename\n        description: file from the experiment to take as an input\n        data_type: file\n      - \n        name: output_filename\n        description: file which will be created inside experiment\n        data_type: str\n  - \n    name: example bash action\n    description: runs a bash script\n    # this may include calling other binaries or\n    # running other language interpreters.\n    # Note, we use `sh` here to run a shell script.\n    # If you want to call it as `./example.sh`, you\n    # should give the file rights to execute: \n    # `chmod +x example.sh`.\n    script: &gt;\n      sh example.sh\n    parameters:\n      - \n        name: string_value\n        description: some string value entered in a textbox.\n        data_type: str\n        default_value: default string\n      -\n        name: experiment\n        description: extension works with the data from this experiment\n        data_type: experiment\n      - \n        name: input_filename\n        description: file from the experiment to take as an input\n        data_type: file\n      - \n        name: output_filename\n        description: file which will be created inside experiment\n        data_type: str\n</code></pre> <p>Each manifest starts with a header with general extension information  (<code>name</code>, <code>description</code>, <code>authors</code>). This information is used to generate  the user interface. The <code>aqueduct_url</code> mandatory parameter is used to make  the extension aware of the instance of Aqueduct it should interact with.  In the current implementation, extensions are assumed to run on the same machine  as the server application, so this address will be a <code>http://localhost:8000/</code> or similar. Port <code>8000</code> is the default port in the container that the Aqueduct server listens to.</p> <p>Optional <code>constants</code> section allows to define key-value pairs for constants shared across all extension action executions. Examples of this may include third-party service credentials, or a database connection string, which are shared among all service installation users. If users need to use such services with different credentials, we encourage you to define a separate action parameter for this purpose.</p> <p>The <code>actions</code> section defines a list of actions an extension may perform. Each item starts with a name and a description used to build user interface.</p> <p>Then a <code>script</code> block defines a linux shell script which triggers execution of the action. If python language is used to run an action, we recommend using <code>$python</code> placeholder:  this will substitute an interpreter with the one from virtual environment created  specifically for this extension. You may add <code>pyproject.toml</code> file and/or <code>requirements.txt</code> file to define your dependencies,  and they will be installed into a python virtual environment at the first action call.</p> <p>Then there is a list of <code>parameters</code>. Each item defines input values passed to the extension action. Each such parameter is defined with:</p> name type comment <code>name</code> text parameter name <code>description</code> text used in the interface to explain the value <code>data_type</code> {<code>str</code>, <code>textarea</code>, <code>file</code>,  <code>experiment</code>, <code>int</code>, <code>float</code>,  <code>select</code>, <code>bool</code>} one of supported data types <code>default_value</code> (optional) of <code>data_type</code> default value, populates the interface field by default <code>options</code> (optional) <code>array</code> collection of optiions. Used with <code>select</code> data type"},{"location":"extensions/#data-types","title":"Data Types","text":"<p>Here is the list of available data types:</p> type values <code>str</code>, <code>textarea</code> arbitrary string <code>experiment</code> string with an experiment ID (EID) <code>file</code> string with a file name inside and experiment <code>select</code> string, one of the listed options <code>float</code>, <code>int</code> numerical types <code>bool</code> True or False. Passed to an extension action as 0 or 1 <p>Please, note, that purpose of extensions is to interact with an experiment. They may generate, process or consume the data from the experiment, that is why each extension action MUST have at least one parameter of <code>experiment</code> type.</p>"},{"location":"extensions/#deploying-an-extension","title":"Deploying an Extension","text":"<p>Extensions are directories which could be distributed in the form of archives. When starting the server using Docker,  bind mount a host directory to the Aqueduct container. Suggested location is <code>/workspace/external/extensions</code>. This location should be provided in <code>EXTENSIONS_DIR_PATH</code> environment variable. Unpack an extension directory into the host directory, and the container will immediately see the changes.</p> <p>For example, if you map host directory <code>/usr/data/extensions</code> to <code>/workspace/external/extensions</code>,  then <code>/usr/data/extensions/dummy/manifest.yml</code> within will become available inside the container as <code>/workspace/external/extensions/dummy/manifest.yml</code>.</p>"},{"location":"extensions/#extension-setup","title":"Extension Setup","text":"<p>Extension may require final adjustment after deployment. Here are potential places for these:</p> <ul> <li>In the manifest file update the <code>aqueduct_url</code> field. By default your extension will access aqueduct at the same machine on port <code>8000</code>, but if you decide to run server application in a different port, or set it to use HTTPS, this should be reflected in the extension manifest.</li> <li><code>constants</code> section, which defines constants for the whole extension, may hold customisable string, for example, access keys or remote service URLs. Define correct values for these constants.</li> <li>Action parameters are allowed to have <code>select</code> type. If necessary, update <code>options</code> list for such fields with respect to your configuration needs.</li> </ul>"},{"location":"getting-started/","title":"PyAqueduct Application Programming Interface (API) Tutorial","text":"<p>In this tutorial, the API of PyAqueduct is introduced by working on a sample experiment. The sample experiment generates some results in the form of different files such as CSV, JSON, HDF5, and image files. Each execution of the experiment generates new set of files and therefore, is treated as a new experiment run.</p>"},{"location":"getting-started/#experiment-analysis-of-projectile-motion","title":"Experiment: analysis of projectile motion","text":"<pre><code># Install experiment dependecies.\nimport sys\n!{sys.executable} -m pip install numpy pandas matplotlib h5py\n</code></pre> <pre><code>import os\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport json\nimport h5py\n\n\ndef simulate_projectile_motion(v0: float, angle: float, g: float = 9.81) -&gt; pd.DataFrame:\n    \"\"\"\n    Simulates the projectile motion.\n\n    Args:\n        v0: Initial velocity in m/s.\n        angle: Launch angle in degrees.\n        g: Acceleration due to gravity in m/s^2 (default is 9.81).\n\n    Returns:\n        DataFrame containing time, x and y positions.\n    \"\"\"\n    # Time of flight calculation\n    t_max = 2 * v0 * np.sin(np.radians(angle)) / g\n    time_steps = np.linspace(0, t_max, num=50)\n\n    # Position calculations\n    x = v0 * np.cos(np.radians(angle)) * time_steps\n    y = v0 * np.sin(np.radians(angle)) * time_steps - 0.5 * g * time_steps**2\n\n    return pd.DataFrame({\"Time (s)\": time_steps, \"X Position (m)\": x, \"Y Position (m)\": y})\n\n\ndef save_data_formats(data: pd.DataFrame, base_path: str) -&gt; None:\n    \"\"\"\n    Saves data in different formats: CSV, JSON, and HDF5.\n\n    Args:\n        data: Data to save.\n        base_path: Base file path without extension.\n    \"\"\"\n    # CSV\n    csv_path = f\"{base_path}.csv\"\n    data.to_csv(csv_path, index=False)\n\n    # JSON\n    json_path = f\"{base_path}.json\"\n    with open(json_path, \"w\") as json_file:\n        json.dump(data.to_dict(orient=\"records\"), json_file)\n\n    # HDF5\n    hdf5_path = f\"{base_path}.hdf5\"\n    with h5py.File(hdf5_path, \"w\") as hdf_file:\n        for column in data.columns:\n            hdf_file.create_dataset(column, data=data[column].values)\n\n\ndef plot_trajectory(data: pd.DataFrame, image_path: str) -&gt; None:\n    \"\"\"\n    Plots the trajectory of the projectile motion.\n\n    Args:\n        data: Data containing the trajectory.\n        image_path: Path to save the plot image.\n    \"\"\"\n    plt.figure(figsize=(8, 6))\n    plt.plot(data[\"X Position (m)\"], data[\"Y Position (m)\"])\n    plt.title(\"Projectile Motion Trajectory\")\n    plt.xlabel(\"X Position (m)\")\n    plt.ylabel(\"Y Position (m)\")\n    plt.grid(True)\n    plt.savefig(image_path)\n\n\n# Parameters for the simulation\ninitial_velocity = 20  # m/s\nlaunch_angle = 45  # degrees\n\n# Simulate the projectile motion\nprojectile_data = simulate_projectile_motion(initial_velocity, launch_angle)\n\n# Save the data in different formats\nbase_file_path = os.path.join(os.getcwd(), \"projectile_motion\")\nsave_data_formats(projectile_data, base_file_path)\n\n# Plot and save the trajectory\nplot_image_path = os.path.join(os.getcwd(), \"projectile_motion_plot.png\")\n\nplot_trajectory(projectile_data, plot_image_path)\n\nprint(\"Simulation and data processing completed.\")\n</code></pre>"},{"location":"getting-started/#create-experiment-on-aqueduct","title":"Create experiment on Aqueduct","text":"<pre><code>from pyaqueduct import API\n\napi = API(\"[AQUEDUCT_SERVER_URL_PLACE_HOLDER]\", timeout=1)\n\nexperiment = api.create_experiment(\n    title=\"Motion Simulation Experiment\", description=\"Tutorial experiment: motion simulation.\"\n)\n\nprint(f\"Experiment created with unique id: {experiment.alias}\")\n</code></pre>"},{"location":"getting-started/#add-tags-to-experiment","title":"Add tags to experiment","text":"<pre><code>experiment.add_tag(\"motion\")\nexperiment.add_tag(\"simulation\")\nexperiment.add_tag(\"notebook\")\n\nexperiment.tags\n</code></pre>"},{"location":"getting-started/#remove-tags-from-experiment","title":"Remove tags from experiment","text":"<pre><code>experiment.remove_tag(\"simulation\")\nexperiment.remove_tag(\"notebook\")\n\nexperiment.tags\n</code></pre>"},{"location":"getting-started/#update-experiment-and-file-downloadupload","title":"Update experiment and file download/upload","text":"<pre><code>experiment.title = \"Motion Simulation\"\nexperiment.description = \"Motion Simulation\"\n\nprint(f\"Experiment title: {experiment.title}\")\nprint(f\"Experiment title: {experiment.description}\")\nprint(f\"Experiment creation date: {experiment.created_at}\")\nprint(f\"Experiment last update date: {experiment.updated_at}\")\nprint(f\"Experiment tags: {experiment.tags}\")\n</code></pre>"},{"location":"getting-started/#upload-files","title":"Upload files","text":"<pre><code>experiment.upload_file(file=\"projectile_motion.csv\")\nexperiment.upload_file(file=\"projectile_motion.json\")\nexperiment.upload_file(file=\"projectile_motion.hdf5\")\nexperiment.upload_file(file=\"projectile_motion_plot.png\")\n</code></pre>"},{"location":"getting-started/#download-files","title":"Download files","text":"<pre><code>download_dir = os.path.join(os.getcwd(), \"downloads\")\nif not os.path.exists(download_dir):\n    os.makedirs(download_dir)\n\nexperiment.download_file(file_name=\"projectile_motion.csv\", destination_dir=download_dir)\nexperiment.download_file(file_name=\"projectile_motion.json\", destination_dir=download_dir)\nexperiment.download_file(file_name=\"projectile_motion.hdf5\", destination_dir=download_dir)\nexperiment.download_file(file_name=\"projectile_motion_plot.png\", destination_dir=download_dir)\n</code></pre>"},{"location":"getting-started/#get-specific-experiment","title":"Get specific experiment","text":"<pre><code>experiment = api.get_experiment(\"[Experiment ID]\")\n\nprint(f\"Experiment title: {experiment.title}\")\nprint(f\"Experiment title: {experiment.description}\")\nprint(f\"Experiment creation date: {experiment.created_at}\")\nprint(f\"Experiment last update date: {experiment.updated_at}\")\nprint(f\"Experiment tags: {experiment.tags}\")\n</code></pre>"},{"location":"setup/","title":"Setup Guide","text":"<p>On this page we provide instructions for two ways to set up Aqueduct: - Using Production Docker Images - Installing from Source </p>"},{"location":"setup/#using-production-docker-images","title":"Using Production Docker Images","text":"<p>For the ease of deployment in production, Aqueduct is released as a production-ready container image. The docker image is available through Dockerhub, <code>aqueducthub/aqueductcore</code>.</p> <p>This example Docker compose file shows how you can use the Docker images:</p> <pre><code>version: '3'\nservices:\n  aqueduct:\n    image: aqueducthub/aqueductcore:latest\n    restart: always\n    depends_on:\n      - postgres\n    environment:\n      EXPERIMENTS_DIR_PATH: /tmp/aqueduct_experiments\n      POSTGRES_USERNAME: admin\n      POSTGRES_PASSWORD: admin\n      POSTGRES_HOST: postgres\n      POSTGRES_PORT: 5432\n      POSTGRES_DB: aqueduct\n    volumes:\n      - /tmp/aqueduct_experiments:/tmp/aqueduct_experiments\n      - type: bind\n        # host folder for extensions\n        source: /aqueductcode/extensions\n        target: /workspace/extensions\n    ports:\n      - 80:8000\n\n  postgres:\n    image: postgres:15-alpine\n    restart: unless-stopped\n    environment:\n      - POSTGRES_USER=admin\n      - POSTGRES_PASSWORD=admin\n      - POSTGRES_DB=aqueduct\n    expose:\n      - 5432\n</code></pre> <p>In this example, the Aqueduct server will be running at [http://localhost]. </p> <p>Note</p> <p>If you are provided with a tar file to install Aqueduct, it already includes the docker image and related configurations. Please refer to the README.md file for further information.</p>"},{"location":"setup/#when-this-option-works-best","title":"When this option works best","text":"<p>This installation method is useful if you are familiar with Docker containers and Docker compose. It allows you to run Aqueduct components in isolation from other software running on the same physical or virtual machine with easy maintenance of dependencies.</p>"},{"location":"setup/#intended-users","title":"Intended users","text":"<ul> <li>Users who are familiar with containers and Docker, and understand how to build their own container images.</li> <li>Users who know how to create deployments using Docker by linking together multiple Docker containers and maintaining such deployments.</li> <li>Users who understand how to install providers and dependencies from PyPI with constraints, if they want to extend or customise the image.</li> </ul>"},{"location":"setup/#what-are-you-expected-to-handle","title":"What are you expected to handle","text":"<ul> <li>You are responsible for setting up database, creating and managing database schema with Aqueduct database commands, automated startup and recovery, maintenance, cleanup and upgrades of Aqueduct.</li> <li>You should choose the right deployment mechanism. There a number of available options of deployments of containers. You can use your own custom mechanism, custom Kubernetes deployments, custom Docker Compose, custom Helm charts etc., and you should choose it based on your experience and expectations.</li> <li>You need to setup monitoring of your system allowing you to observe resources and react to problems.</li> <li>You are expected to configure and manage appropriate resources for the installation (memory, CPU, etc) based on the monitoring of your installation and feedback loop.</li> </ul>"},{"location":"setup/#installing-from-source","title":"Installing from Source","text":"<ol> <li>Pre-requisites<ul> <li>Python installed on your system (version 3.8 or higher)</li> <li>PostgreSQL installed and running</li> </ul> </li> <li> <p>Clone the Repository Clone the repository of your Python web application from the source repository using git or download the source code.</p> <pre><code>git clone &lt;repository_url&gt;\ncd &lt;project_directory&gt;\n</code></pre> </li> <li> <p>Set up Virtual Environment (Optional but recommended)</p> <pre><code># Install virtualenv if you haven't already\npip install virtualenv\n\n# Create a virtual environment (replace 'env_name' with your preferred name)\nvirtualenv env_name\n\nsource env_name/bin/activate\n</code></pre> </li> <li> <p>Install Aqueduct     <pre><code>pip install &lt;project_directory&gt;\n</code></pre></p> </li> <li> <p>Set Environment Variables Before running the application, you need to set the required environment variables. These variables are essential for connecting to the PostgreSQL database and other functionalities.</p> <pre><code># Set the required environment variables (replace with your actual values)\nexport EXPERIMENTS_DIR_PATH=&lt;your_experiment_directory_path&gt;\nexport POSTGRES_USERNAME=&lt;your_postgres_username&gt;\nexport POSTGRES_PASSWORD=&lt;your_postgres_password&gt;\nexport POSTGRES_HOST=&lt;your_postgres_host&gt;\nexport POSTGRES_PORT=&lt;your_postgres_port&gt;\nexport POSTGRES_DB=&lt;your_postgres_database_name&gt;\nexport EXTENSIONS_DIR_PATH=&lt;your_extensions_directory_path&gt;\n</code></pre> </li> <li> <p>Configure PostgreSQL: Ensure that your PostgreSQL database is properly configured and accessible with the provided credentials.</p> </li> <li> <p>Run the Application: Run the Python web application using the following command:     <pre><code>python app.py\n</code></pre> This command might differ based on how your application is structured and what file initializes your web server.</p> </li> <li> <p>Access the Application: Once the application is running, open a web browser and navigate to http://localhost: to access the application. Replace  with the port specified in your application setup."},{"location":"setup/#additional-notes","title":"Additional Notes:","text":"<ul> <li>Ensure the PostgreSQL server is running before starting the application.</li> <li>Make sure to keep sensitive information like passwords and usernames secure. Avoid hardcoding them in your code.</li> <li>Double-check the correctness of the environment variable values to avoid connection issues with the PostgreSQL database.</li> </ul>"}]}